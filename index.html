/* =======================================================================
   THE NAMELESS CHRONICLE — INDEX.JS
   A complete, production-ready controller for your interactive journal.
   -----------------------------------------------------------------------
   Features:
   - 3D Page Flip Engine (click or arrow keys)
   - Rune Unlock System (with True Name universal unlock)
   - Seal Animation + Sound on success
   - Scare System on wrong rune (custom VO + loud scream, 3s red flash)
   - Ambient Audio (starts on first click)
   - Dynamic Entry Loader (entries/*.html → new book pages)
   - Persistent Progress via localStorage
   - Finale Trigger when all key runes are unlocked
   - Silent Easter Eggs (no hints shown to players)
   - Minimal Dev Console (toggle with Shift+~)
   -----------------------------------------------------------------------
   Author: Vaelin Thorne (DM)
   Version: 1.0.0
   ======================================================================= */

(() => {
  "use strict";

  /* ──────────────────────────────────────────────────────────────────────
     0) CONFIGURATION
     ──────────────────────────────────────────────────────────────────── */
  const CFG = {
    // Rune → files to unlock (relative to /entries/)
    RUNES: {
      OCEANUS: ['plane_water_1.html', 'plane_water_2.html', 'plane_water_3.html'],
      DAWNFALL: ['plane_air_1.html', 'plane_air_2.html', 'plane_air_3.html'],
      AURIC: ['plane_fire_1.html', 'plane_fire_2.html', 'plane_fire_3.html'],
      ABYSSAL: ['plane_abyss_1.html', 'plane_abyss_2.html'],
      TEMPLEVEIL: ['god_koriel_myth.html', 'god_koriel_fall.html'],
      STORMCROWN: ['secret_stormvault.html', 'field_08.html'],
      ASTRAEL: ['god_astrael_dream.html', 'god_astrael_corrupt.html'],
      // VAELINTHORNE (True Name) is handled specially — unlocks everything
    },

    ALWAYS_UNLOCKED: new Set([
      // Allow a few starter pages so the book is always usable
      'plane_water_1.html', 'plane_water_2.html', 'plane_water_3.html'
    ]),

    IDS: {
      book: 'chronicleBook',
      runeInput: 'runeInput',
      runeBtn: 'runeBtn',
      sealOverlay: 'sealOverlay',
      scareOverlay: 'scareOverlay',
      title: 'bookTitle' // optional; if present, 7-click secret
    },

    SOUNDS: {
      ambient: 'assets/sounds/ambient_torch.mp3',
      seal: 'assets/sounds/fire-effect-367659.mp3',
      whisper: 'assets/sounds/creepy-whispering-6690.mp3', // optional
      wrongLine: 'assets/sounds/youre-not-supposed-to-be-here-made-with-Voicemod.mp3',
      wrongScream: 'assets/sounds/bird-screaming-meme-made-with-Voicemod.mp3',
      page: 'assets/sounds/page_turn.mp3', // optional
    },

    IMAGES: {
      seal: 'assets/images/seal_glow.png',
      parchment: 'assets/images/parchment_bg.jpg'
    },

    // Book behaviour
    PAGE_HEIGHT: 640,
    FLIP_DURATION_MS: 1100,

    // Finale target page
    FINALE_TARGET: 'entries/true_ending.html',

    // Easter egg controls (no visible hints)
    EASTER: {
      enabled: true,
      titleClicksForPrompt: 7, // if #bookTitle exists
      randomWhisperChance: 0.02, // 2% every interval
      randomWhisperIntervalMs: 13000
    },

    // Dev mode (console overlay) — toggle with Shift+~
    DEV: {
      enabled: false
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     1) STATE
     ──────────────────────────────────────────────────────────────────── */
  const State = {
    bookEl: null,
    runeInput: null,
    runeBtn: null,
    sealOverlay: null,
    scareOverlay: null,
    titleEl: null,

    pages: [],
    currentIndex: 0,
    flipped: new Set(),

    ambient: null,
    sfx: {
      seal: null,
      whisper: null,
      wrongLine: null,
      wrongScream: null,
      page: null
    },

    attempts: 0,
    sealedHard: false,

    // progress
    totalRequired: 0,
    unlockedCache: new Set(), // filenames (entries) marked unlocked
    allUnlockedOnce: false,
    devConsole: null,
  };

  /* ──────────────────────────────────────────────────────────────────────
     2) UTILITIES
     ──────────────────────────────────────────────────────────────────── */
  const U = {
    $(id) {
      return document.getElementById(id);
    },
    q(sel, root = document) {
      return root.querySelector(sel);
    },
    qa(sel, root = document) {
      return Array.from(root.querySelectorAll(sel));
    },
    delay(ms) {
      return new Promise(res => setTimeout(res, ms));
    },
    log(...args) {
      if (CFG.DEV.enabled) console.log('[DEV]', ...args);
      if (State.devConsole) State.devConsole.write(args.map(String).join(' '));
    },
    warn(...args) {
      console.warn('[Chronicle]', ...args);
      if (State.devConsole) State.devConsole.write('[WARN] ' + args.map(String).join(' '));
    },
    ensureAssets() {
      // cheap preloads
      const img = new Image();
      img.src = CFG.IMAGES.seal;
      const img2 = new Image();
      img2.src = CFG.IMAGES.parchment;
    },
    // Local storage helpers
    _key(file) { return 'u_' + file; },
    isUnlocked(file) {
      if (CFG.ALWAYS_UNLOCKED.has(file)) return true;
      return localStorage.getItem(U._key(file)) === '1';
    },
    unlock(file) {
      localStorage.setItem(U._key(file), '1');
      State.unlockedCache.add(file);
    },
    unlockMany(list) {
      list.forEach(U.unlock);
    },
    unlockAllKnown() {
      const all = new Set();
      Object.values(CFG.RUNES).forEach(arr => arr.forEach(f => all.add(f)));
      all.forEach(U.unlock);
      State.allUnlockedOnce = true;
    },
    listAllRequired() {
      const s = new Set();
      Object.entries(CFG.RUNES).forEach(([rune, arr]) => {
        if (rune === 'VAELINTHORNE') return; // not a normal requirement
        arr.forEach(f => s.add(f));
      });
      return s;
    },
    canFinale() {
      // All required files from RUNES must be unlocked
      const req = U.listAllRequired();
      for (const f of req) {
        if (!U.isUnlocked(f)) return false;
      }
      return true;
    },
  };

  /* ──────────────────────────────────────────────────────────────────────
     3) AUDIO MANAGER
     ──────────────────────────────────────────────────────────────────── */
  const AudioMgr = {
    init() {
      try {
        State.sfx.seal = new Audio(CFG.SOUNDS.seal);
      } catch (e) { U.warn('Missing seal sound', e); }
      try {
        State.sfx.whisper = new Audio(CFG.SOUNDS.whisper);
      } catch (e) { /* optional */ }
      try {
        State.sfx.wrongLine = new Audio(CFG.SOUNDS.wrongLine);
      } catch (e) { U.warn('Missing wrongLine sound', e); }
      try {
        State.sfx.wrongScream = new Audio(CFG.SOUNDS.wrongScream);
      } catch (e) { U.warn('Missing wrongScream sound', e); }
      try {
        State.sfx.page = new Audio(CFG.SOUNDS.page);
      } catch (e) { /* optional */ }
    },
    playAmbientOnce() {
      if (State.ambient) return;
      try {
        const amb = new Audio(CFG.SOUNDS.ambient);
        amb.loop = true; amb.volume = 0.25;
        amb.play().catch(()=>{});
        State.ambient = amb;
      } catch (e) { U.warn('Ambient failed', e); }
    },
    playSeal() {
      try {
        if (State.sfx.seal) { State.sfx.seal.currentTime = 0; State.sfx.seal.volume = 0.5; State.sfx.seal.play().catch(()=>{}); }
      } catch (e) { /* ignore */ }
    },
    playWhisper(vol = 0.35) {
      try {
        if (State.sfx.whisper) { State.sfx.whisper.currentTime = 0; State.sfx.whisper.volume = vol; State.sfx.whisper.play().catch(()=>{}); }
      } catch (e) { /* ignore */ }
    },
    playPage() {
      try {
        if (State.sfx.page) { State.sfx.page.currentTime = 0; State.sfx.page.volume = 0.45; State.sfx.page.play().catch(()=>{}); }
      } catch (e) { /* ignore */ }
    },
    playWrongLine() {
      try {
        if (State.sfx.wrongLine) { State.sfx.wrongLine.currentTime = 0; State.sfx.wrongLine.volume = 1.0; State.sfx.wrongLine.play().catch(()=>{}); }
      } catch (e) { /* ignore */ }
    },
    playWrongScream() {
      try {
        if (State.sfx.wrongScream) { State.sfx.wrongScream.currentTime = 0; State.sfx.wrongScream.volume = 1.0; State.sfx.wrongScream.play().catch(()=>{}); }
      } catch (e) { /* ignore */ }
    },
    squareBlast() {
      // fallback blast if audio blocked
      try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        const ctx = new Ctx();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'square'; o.frequency.value = 220;
        g.gain.setValueAtTime(0.0001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + 0.03);
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.45);
        o.connect(g).connect(ctx.destination); o.start(); o.stop(ctx.currentTime + 0.48);
      } catch (e) { /* ignore */ }
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     4) OVERLAYS (SEAL + SCARE)
     ──────────────────────────────────────────────────────────────────── */
  const Overlays = {
    showSeal() {
      if (!State.sealOverlay) return;
      State.sealOverlay.classList.remove('hidden');
      // ensure .show triggers transition
      requestAnimationFrame(() => State.sealOverlay.classList.add('show'));
      AudioMgr.playSeal();
      setTimeout(() => {
        State.sealOverlay.classList.remove('show');
        setTimeout(() => State.sealOverlay.classList.add('hidden'), 700);
      }, 1200);
    },
    async scare() {
      if (!State.scareOverlay) return;

      // Flash ON
      State.scareOverlay.classList.remove('hidden');
      State.scareOverlay.classList.add('on');

      // Play “You’re not supposed to be here” (custom VO)
      AudioMgr.playWrongLine();

      // After ~1s, the very loud scream
      setTimeout(() => {
        AudioMgr.playWrongScream();
      }, 1000);

      // Keep red flash for ~3s, then fade out
      setTimeout(() => {
        State.scareOverlay.classList.remove('on');
        setTimeout(() => State.scareOverlay.classList.add('hidden'), 1000);
      }, 3000);

      // Fallback blast if both audio calls fail
      setTimeout(() => AudioMgr.squareBlast(), 1200);
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     5) BOOK ENGINE (3D FLIP)
     ──────────────────────────────────────────────────────────────────── */
  const Book = {
    init() {
      State.bookEl = U.$(CFG.IDS.book);
      if (!State.bookEl) {
        U.warn('Missing #chronicleBook element');
        return;
      }

      // collect pages (direct children with .page)
      State.pages = U.qa('.page', State.bookEl);
      State.pages.forEach((page, i) => {
        page.style.zIndex = (State.pages.length - i);
        page.dataset.pageIndex = String(i);
        page.style.height = CFG.PAGE_HEIGHT + 'px';
        page.addEventListener('click', () => Book.toggle(i));
      });

      document.addEventListener('keydown', e => {
        if (e.key === 'ArrowRight') Book.next();
        else if (e.key === 'ArrowLeft') Book.prev();
      });
    },

    toggle(i) {
      if (State.sealedHard) return;
      const p = State.pages[i];
      if (!p) return;
      const isOpen = p.classList.contains('open');
      if (isOpen) {
        p.classList.remove('open');
        State.flipped.delete(i);
        State.currentIndex = Math.max(0, State.currentIndex - 1);
      } else {
        p.classList.add('open');
        State.flipped.add(i);
        State.currentIndex = Math.min(State.pages.length - 1, State.currentIndex + 1);
      }
      AudioMgr.playPage();
    },

    next() {
      if (State.sealedHard) return;
      if (State.currentIndex < State.pages.length - 1) {
        Book.toggle(State.currentIndex);
      }
    },

    prev() {
      if (State.sealedHard) return;
      if (State.currentIndex > 0) {
        Book.toggle(State.currentIndex - 1);
      }
    },

    appendEntryPage(title, html) {
      if (!State.bookEl) return;
      const page = document.createElement('div');
      page.className = 'page';
      page.style.height = CFG.PAGE_HEIGHT + 'px';
      page.innerHTML = `<h1>${title}</h1>` + html;
      State.bookEl.appendChild(page);

      // rebuild page list and stacks
      State.pages = U.qa('.page', State.bookEl);
      State.pages.forEach((p, i) => {
        p.style.zIndex = (State.pages.length - i);
        p.dataset.pageIndex = String(i);
        if (!p._bound) {
          p.addEventListener('click', () => Book.toggle(i));
          p._bound = true;
        }
      });

      // auto-reveal by flipping previous
      const last = State.pages.length - 1;
      const prev = last - 1;
      if (prev >= 0) {
        const prevPage = State.pages[prev];
        if (prevPage && !prevPage.classList.contains('open')) {
          prevPage.classList.add('open');
          State.flipped.add(prev);
          State.currentIndex = last;
          AudioMgr.playPage();
        }
      }
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     6) LOCK / UNLOCK SYSTEM
     ──────────────────────────────────────────────────────────────────── */
  const Locks = {
    refreshLockBadges() {
      // If you have a sidebar TOC of <a class="toc" data-file="..."> links,
      // mark them as locked / unlocked.
      U.qa('a.toc').forEach(a => {
        const file = a.getAttribute('data-file');
        if (!file) return;
        let tag = a.querySelector('.locked-tag');
        if (U.isUnlocked(file)) {
          a.classList.remove('locked-link');
          if (tag) tag.remove();
        } else {
          a.classList.add('locked-link');
          if (!tag) {
            const span = document.createElement('span');
            span.className = 'locked-tag';
            span.textContent = ' (locked)';
            a.appendChild(span);
          }
        }
      });
    },

    setInitialUnlocks() {
      // Always unlocked
      CFG.ALWAYS_UNLOCKED.forEach(f => U.unlock(f));
      // cache
      State.unlockedCache = new Set(
        Object.keys(localStorage)
          .filter(k => k.startsWith('u_') && localStorage.getItem(k) === '1')
          .map(k => k.slice(2))
      );
    },

    unlockByRune(runeWord) {
      const list = CFG.RUNES[runeWord];
      if (!list) return false;
      U.unlockMany(list);
      Overlays.showSeal();
      Locks.refreshLockBadges();
      Finale.maybeTrigger();
      return true;
    },

    unlockAllByTrueName() {
      U.unlockAllKnown();
      Overlays.showSeal();
      Locks.refreshLockBadges();
      Finale.maybeTrigger();
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     7) RUNE INPUT HANDLER
     ──────────────────────────────────────────────────────────────────── */
  const Runes = {
    attempt(inputValRaw) {
      const word = (inputValRaw || '').toUpperCase().trim();
      if (!word) return;

      // True Name removes all seals
      if (word.replace(/\s+/g, '') === 'VAELINTHORNE') {
        Locks.unlockAllByTrueName();
        return;
      }

      // Normal runes
      const ok = Locks.unlockByRune(word);
      if (!ok) {
        State.attempts++;
        Overlays.scare();
        if (State.attempts >= 3) {
          State.sealedHard = true;
          alert('The Chronicle seals itself shut until the next dawn…');
        }
      }
    },

    bindControls() {
      State.runeInput = U.$(CFG.IDS.runeInput);
      State.runeBtn = U.$(CFG.IDS.runeBtn);
      if (State.runeBtn) {
        State.runeBtn.addEventListener('click', (evt) => {
          evt.preventDefault();
          const v = State.runeInput ? State.runeInput.value : '';
          Runes.attempt(v);
          if (State.runeInput) State.runeInput.value = '';
        });
      }
      if (State.runeInput) {
        State.runeInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            const v = State.runeInput.value;
            Runes.attempt(v);
            State.runeInput.value = '';
          }
        });
      }
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     8) ENTRY LOADER
     ──────────────────────────────────────────────────────────────────── */
  const Entries = {
    bindTOC() {
      U.qa('a.toc').forEach(a => {
        a.addEventListener('click', async (evt) => {
          evt.preventDefault();
          const file = a.getAttribute('data-file');
          const title = a.textContent.replace(' (locked)', '');
          if (!file) return;

          if (!U.isUnlocked(file)) {
            Overlays.scare();
            return;
          }

          try {
            const html = await Entries.fetchEntry(file);
            Book.appendEntryPage(title, html);
          } catch (e) {
            U.warn('Failed to fetch entry:', file, e);
          }
        });
      });
    },

    async fetchEntry(file) {
      const res = await fetch('entries/' + file, { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      return await res.text();
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     9) EASTER EGGS (SILENT)
     ──────────────────────────────────────────────────────────────────── */
  const Easter = {
    titleClickCount: 0,
    init() {
      if (!CFG.EASTER.enabled) return;
      State.titleEl = U.$(CFG.IDS.title) || U.q('header h1');
      if (State.titleEl) {
        State.titleEl.addEventListener('click', () => {
          Easter.titleClickCount++;
          if (Easter.titleClickCount >= CFG.EASTER.titleClicksForPrompt) {
            Easter.titleClickCount = 0;
            const name = prompt('The margin whispers: Your True Name?');
            if ((name || '').replace(/\s+/g, '').toUpperCase() === 'VAELINTHORNE') {
              Locks.unlockAllByTrueName();
            } else {
              Overlays.scare();
            }
          }
        });
      }

      // Random whisper loop (no hints)
      setInterval(() => {
        if (Math.random() < CFG.EASTER.randomWhisperChance) {
          AudioMgr.playWhisper(0.28);
        }
      }, CFG.EASTER.randomWhisperIntervalMs);

      // “Hidden” interactions can be expanded here if desired.
      // Keep them atmospheric only; no UI hints.
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     10) FINALE
     ──────────────────────────────────────────────────────────────────── */
  const Finale = {
    maybeTrigger() {
      if (!U.canFinale()) return;

      // Dramatic blue seal + fade to finale target
      setTimeout(() => {
        if (!State.sealOverlay) return;
        State.sealOverlay.classList.remove('hidden');
        State.sealOverlay.classList.add('show');
        AudioMgr.playSeal();

        setTimeout(() => {
          State.sealOverlay.classList.remove('show');
          setTimeout(() => State.sealOverlay.classList.add('hidden'), 500);
          // fade to black + redirect
          const fade = document.createElement('div');
          Object.assign(fade.style, {
            position: 'fixed', inset: '0', background: '#000',
            opacity: '0', transition: 'opacity 2.5s ease', zIndex: '2000'
          });
          document.body.appendChild(fade);
          requestAnimationFrame(() => {
            fade.style.opacity = '1';
            setTimeout(() => { window.location.href = CFG.FINALE_TARGET; }, 2600);
          });
        }, 1600);
      }, 600);
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     11) DEV CONSOLE (OPTIONAL)
     ──────────────────────────────────────────────────────────────────── */
  const Dev = {
    build() {
      if (!CFG.DEV.enabled) return;
      const box = document.createElement('div');
      box.style.cssText = `
        position: fixed; right: 8px; bottom: 8px; width: 340px; height: 200px;
        background: rgba(0,0,0,.7); color: #cde; font-family: monospace; font-size: 12px;
        border: 1px solid #456; border-radius: 6px; padding: 6px; z-index: 3000; display:none;
      `;
      const pre = document.createElement('pre');
      pre.style.cssText = 'margin:0; height: 165px; overflow:auto;';
      const row = document.createElement('div');
      row.style.cssText = 'display:flex; gap:6px; margin-top:4px;';
      const input = document.createElement('input');
      input.placeholder = 'Dev cmd... (ex: unlockAll)';
      input.style.cssText = 'flex:1; background:#123; color:#cde; border:1px solid #345; border-radius:4px; padding:4px;';
      const btn = document.createElement('button');
      btn.textContent = 'Run';
      btn.style.cssText = 'background:#246; color:#fff; border:0; padding:4px 8px; border-radius:4px; cursor:pointer;';
      row.appendChild(input); row.appendChild(btn);
      box.appendChild(pre); box.appendChild(row);
      document.body.appendChild(box);

      State.devConsole = {
        el: box, logEl: pre, input, open: false,
        write(msg) {
          const line = document.createElement('div');
          line.textContent = String(msg);
          pre.appendChild(line);
          pre.scrollTop = pre.scrollHeight;
        },
        toggle() {
          this.open = !this.open;
          box.style.display = this.open ? 'block' : 'none';
        }
      };

      btn.addEventListener('click', () => Dev.run(input.value));
      input.addEventListener('keydown', (e) => { if (e.key === 'Enter') Dev.run(input.value); });

      document.addEventListener('keydown', (e) => {
        if (e.shiftKey && (e.key === '`' || e.code === 'Backquote')) {
          State.devConsole.toggle();
        }
      });

      U.log('Dev console ready. Shift+` to toggle.');
    },

    run(cmd) {
      if (!cmd) return;
      const c = cmd.trim().toLowerCase();
      if (c === 'unlockall') { Locks.unlockAllByTrueName(); State.devConsole.write('OK: unlockAll'); }
      else if (c.startsWith('unlock ')) {
        const rune = c.split(' ')[1]?.toUpperCase();
        if (rune && CFG.RUNES[rune]) { Locks.unlockByRune(rune); State.devConsole.write('OK: unlock ' + rune); }
        else State.devConsole.write('Unknown rune: ' + rune);
      }
      else if (c === 'finale') { Finale.maybeTrigger(); State.devConsole.write('Finale attempted'); }
      else if (c.startsWith('open ')) {
        const f = c.slice(5);
        Entries.fetchEntry(f).then(html => {
          Book.appendEntryPage(f, html);
          State.devConsole.write('Opened: ' + f);
        }).catch(() => State.devConsole.write('Failed to open: ' + f));
      }
      else State.devConsole.write('Unknown cmd: ' + c);
      State.devConsole.input.value = '';
    }
  };

  /* ──────────────────────────────────────────────────────────────────────
     12) SAFETY / WIRING CHECKS
     ──────────────────────────────────────────────────────────────────── */
  function checkRequiredDOM() {
    const missing = [];
    if (!(State.bookEl = U.$(CFG.IDS.book))) missing.push('#' + CFG.IDS.book);
    if (!(State.sealOverlay = U.$(CFG.IDS.sealOverlay))) missing.push('#' + CFG.IDS.sealOverlay);
    if (!(State.scareOverlay = U.$(CFG.IDS.scareOverlay))) missing.push('#' + CFG.IDS.scareOverlay);
    State.runeInput = U.$(CFG.IDS.runeInput);
    State.runeBtn = U.$(CFG.IDS.runeBtn);

    if (missing.length) {
      U.warn('Missing DOM elements:', missing.join(', '));
    }
  }

  function checkAssets() {
    // simple HEAD requests are blocked for file:// — rely on runtime errors.
    U.ensureAssets();
  }

  /* ──────────────────────────────────────────────────────────────────────
     13) INIT
     ──────────────────────────────────────────────────────────────────── */
  async function init() {
    // Bind ambient audio to first user click
    window.addEventListener('click', AudioMgr.playAmbientOnce, { once: true });

    checkRequiredDOM();
    checkAssets();
    AudioMgr.init();
    Dev.build();

    // Book pages present at load
    Book.init();

    // Locks and TOC
    Locks.setInitialUnlocks();
    Locks.refreshLockBadges();
    Entries.bindTOC();

    // Runes
    Runes.bindControls();

    // Easter eggs (silent)
    Easter.init();

    // If all requirements already satisfied (from previous session), trigger finale
    setTimeout(() => Finale.maybeTrigger(), 800);
  }

  document.addEventListener('DOMContentLoaded', init);

  /* ──────────────────────────────────────────────────────────────────────
     14) OPTIONAL: PUBLIC API (for console)
     ──────────────────────────────────────────────────────────────────── */
  window.__Chronicle = {
    attemptRune: (w) => Runes.attempt(w),
    openEntry: async (file) => {
      if (!U.isUnlocked(file)) return Overlays.scare();
      const html = await Entries.fetchEntry(file);
      Book.appendEntryPage(file, html);
    },
    unlockAll: () => Locks.unlockAllByTrueName(),
    unlockRune: (r) => Locks.unlockByRune((r || '').toUpperCase()),
    finale: () => Finale.maybeTrigger(),
  };

  /* ──────────────────────────────────────────────────────────────────────
     15) STYLISTIC EXTRAS (OPTIONAL HOOKS)
     ──────────────────────────────────────────────────────────────────── */
  // These can be used by CSS to reflect progress subtly (no spoilers).
  function reflectProgressGlow() {
    const req = U.listAllRequired();
    let count = 0; req.forEach(f => { if (U.isUnlocked(f)) count++; });
    const ratio = req.size ? count / req.size : 0;
    if (State.bookEl) {
      State.bookEl.style.boxShadow = `0 0 ${Math.floor(10 + ratio * 60)}px ${Math.floor(ratio * 24)}px rgba(94,203,255,${0.2 + ratio * 0.5})`;
    }
  }
  setInterval(reflectProgressGlow, 4000);
})();
